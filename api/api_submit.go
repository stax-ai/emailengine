/*
EmailEngine API

EmailEngine provides a RESTful API for managing email accounts, sending messages, and processing email data across multiple providers.  <h3>Authentication</h3> All API requests require authentication using an Access Token. You can generate and manage your tokens from the <a href=\"/admin/tokens\" target=\"_parent\"><strong>Access Tokens</strong></a> page.  Include your token in requests using one of these methods: - Query parameter: <code>?access_token=YOUR_TOKEN</code> - Authorization header: <code>Authorization: Bearer YOUR_TOKEN</code>  <h3>Request Processing</h3>  <strong>Sequential Processing:</strong> Requests to the same email account are processed sequentially to maintain data consistency. Multiple simultaneous requests will be queued.  <strong>Timeouts:</strong> Long-running operations may cause queued requests to timeout. Configure appropriate timeout values using the <code>X-EE-Timeout</code> header (in milliseconds).  <h3>Getting Started</h3> 1. <a href=\"/admin/tokens\" target=\"_parent\">Generate an Access Token</a> 2. <a href=\"/admin/accounts\" target=\"_parent\">Add an email account</a> 3. Start making API requests using the endpoints below

API version: 2.61.1
Contact: support@emailengine.app
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SubmitAPIService SubmitAPI service
type SubmitAPIService service

type ApiPostV1AccountAccountSubmitRequest struct {
	ctx context.Context
	ApiService *SubmitAPIService
	account string
	xEeTimeout *int32
	idempotencyKey *string
	documentStore *bool
	useStructuredFormat *bool
	submitMessage *SubmitMessage
}

// Request timeout in milliseconds (overrides EENGINE_TIMEOUT environment variable)
func (r ApiPostV1AccountAccountSubmitRequest) XEeTimeout(xEeTimeout int32) ApiPostV1AccountAccountSubmitRequest {
	r.xEeTimeout = &xEeTimeout
	return r
}

// Unique key to prevent duplicate processing of the same request
func (r ApiPostV1AccountAccountSubmitRequest) IdempotencyKey(idempotencyKey string) ApiPostV1AccountAccountSubmitRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If enabled then fetch email used as a reference template from the Document Store
func (r ApiPostV1AccountAccountSubmitRequest) DocumentStore(documentStore bool) ApiPostV1AccountAccountSubmitRequest {
	r.documentStore = &documentStore
	return r
}

// For MS Graph accounts: If true, uses structured JSON format (respects from field for shared mailboxes, breaks calendar invites and special MIME types). If false, sends as raw MIME (preserves calendar invites, ignores from field). Default is false (raw MIME).
func (r ApiPostV1AccountAccountSubmitRequest) UseStructuredFormat(useStructuredFormat bool) ApiPostV1AccountAccountSubmitRequest {
	r.useStructuredFormat = &useStructuredFormat
	return r
}

func (r ApiPostV1AccountAccountSubmitRequest) SubmitMessage(submitMessage SubmitMessage) ApiPostV1AccountAccountSubmitRequest {
	r.submitMessage = &submitMessage
	return r
}

func (r ApiPostV1AccountAccountSubmitRequest) Execute() (*SubmitMessageResponse, *http.Response, error) {
	return r.ApiService.PostV1AccountAccountSubmitExecute(r)
}

/*
PostV1AccountAccountSubmit Submit message for delivery

Submit message for delivery. If reference message ID is provided then EmailEngine adds all headers and flags required for a reply/forward automatically.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param account Unique identifier for the email account
 @return ApiPostV1AccountAccountSubmitRequest
*/
func (a *SubmitAPIService) PostV1AccountAccountSubmit(ctx context.Context, account string) ApiPostV1AccountAccountSubmitRequest {
	return ApiPostV1AccountAccountSubmitRequest{
		ApiService: a,
		ctx: ctx,
		account: account,
	}
}

// Execute executes the request
//  @return SubmitMessageResponse
func (a *SubmitAPIService) PostV1AccountAccountSubmitExecute(r ApiPostV1AccountAccountSubmitRequest) (*SubmitMessageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitMessageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubmitAPIService.PostV1AccountAccountSubmit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{account}/submit"
	localVarPath = strings.Replace(localVarPath, "{"+"account"+"}", url.PathEscape(parameterValueToString(r.account, "account")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.account) > 256 {
		return localVarReturnValue, nil, reportError("account must have less than 256 elements")
	}

	if r.documentStore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "documentStore", r.documentStore, "form", "")
	} else {
		var defaultValue bool = false
		r.documentStore = &defaultValue
	}
	if r.useStructuredFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useStructuredFormat", r.useStructuredFormat, "form", "")
	} else {
		var defaultValue bool = false
		r.useStructuredFormat = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEeTimeout != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ee-timeout", r.xEeTimeout, "simple", "")
	}
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "idempotency-key", r.idempotencyKey, "simple", "")
	}
	// body params
	localVarPostBody = r.submitMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
