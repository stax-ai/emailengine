/*
EmailEngine API

EmailEngine provides a RESTful API for managing email accounts, sending messages, and processing email data across multiple providers.  <h3>Authentication</h3> All API requests require authentication using an Access Token. You can generate and manage your tokens from the <a href=\"/admin/tokens\" target=\"_parent\"><strong>Access Tokens</strong></a> page.  Include your token in requests using one of these methods: - Query parameter: <code>?access_token=YOUR_TOKEN</code> - Authorization header: <code>Authorization: Bearer YOUR_TOKEN</code>  <h3>Request Processing</h3>  <strong>Sequential Processing:</strong> Requests to the same email account are processed sequentially to maintain data consistency. Multiple simultaneous requests will be queued.  <strong>Timeouts:</strong> Long-running operations may cause queued requests to timeout. Configure appropriate timeout values using the <code>X-EE-Timeout</code> header (in milliseconds).  <h3>Getting Started</h3> 1. <a href=\"/admin/tokens\" target=\"_parent\">Generate an Access Token</a> 2. <a href=\"/admin/accounts\" target=\"_parent\">Add an email account</a> 3. Start making API requests using the endpoints below

API version: 2.61.1
Contact: support@emailengine.app
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MessageAPIService MessageAPI service
type MessageAPIService service

type ApiDeleteV1AccountAccountMessageMessageRequest struct {
	ctx context.Context
	ApiService *MessageAPIService
	account string
	message string
	xEeTimeout *int32
	force *bool
}

// Request timeout in milliseconds (overrides EENGINE_TIMEOUT environment variable)
func (r ApiDeleteV1AccountAccountMessageMessageRequest) XEeTimeout(xEeTimeout int32) ApiDeleteV1AccountAccountMessageMessageRequest {
	r.xEeTimeout = &xEeTimeout
	return r
}

// Delete message even if not in Trash. Not supported for Gmail API accounts.
func (r ApiDeleteV1AccountAccountMessageMessageRequest) Force(force bool) ApiDeleteV1AccountAccountMessageMessageRequest {
	r.force = &force
	return r
}

func (r ApiDeleteV1AccountAccountMessageMessageRequest) Execute() (*MessageDeleteResponse, *http.Response, error) {
	return r.ApiService.DeleteV1AccountAccountMessageMessageExecute(r)
}

/*
DeleteV1AccountAccountMessageMessage Delete message

Move message to Trash or delete it if already in Trash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param account Unique identifier for the email account
 @param message Message ID
 @return ApiDeleteV1AccountAccountMessageMessageRequest
*/
func (a *MessageAPIService) DeleteV1AccountAccountMessageMessage(ctx context.Context, account string, message string) ApiDeleteV1AccountAccountMessageMessageRequest {
	return ApiDeleteV1AccountAccountMessageMessageRequest{
		ApiService: a,
		ctx: ctx,
		account: account,
		message: message,
	}
}

// Execute executes the request
//  @return MessageDeleteResponse
func (a *MessageAPIService) DeleteV1AccountAccountMessageMessageExecute(r ApiDeleteV1AccountAccountMessageMessageRequest) (*MessageDeleteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageDeleteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.DeleteV1AccountAccountMessageMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{account}/message/{message}"
	localVarPath = strings.Replace(localVarPath, "{"+"account"+"}", url.PathEscape(parameterValueToString(r.account, "account")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message"+"}", url.PathEscape(parameterValueToString(r.message, "message")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.account) > 256 {
		return localVarReturnValue, nil, reportError("account must have less than 256 elements")
	}
	if strlen(r.message) > 256 {
		return localVarReturnValue, nil, reportError("message must have less than 256 elements")
	}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	} else {
		var defaultValue bool = false
		r.force = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEeTimeout != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ee-timeout", r.xEeTimeout, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetV1AccountAccountAttachmentAttachmentRequest struct {
	ctx context.Context
	ApiService *MessageAPIService
	account string
	attachment string
	xEeTimeout *int32
}

// Request timeout in milliseconds (overrides EENGINE_TIMEOUT environment variable)
func (r ApiGetV1AccountAccountAttachmentAttachmentRequest) XEeTimeout(xEeTimeout int32) ApiGetV1AccountAccountAttachmentAttachmentRequest {
	r.xEeTimeout = &xEeTimeout
	return r
}

func (r ApiGetV1AccountAccountAttachmentAttachmentRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetV1AccountAccountAttachmentAttachmentExecute(r)
}

/*
GetV1AccountAccountAttachmentAttachment Download attachment

Fetches attachment file as a binary stream

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param account Unique identifier for the email account
 @param attachment Attachment ID
 @return ApiGetV1AccountAccountAttachmentAttachmentRequest
*/
func (a *MessageAPIService) GetV1AccountAccountAttachmentAttachment(ctx context.Context, account string, attachment string) ApiGetV1AccountAccountAttachmentAttachmentRequest {
	return ApiGetV1AccountAccountAttachmentAttachmentRequest{
		ApiService: a,
		ctx: ctx,
		account: account,
		attachment: attachment,
	}
}

// Execute executes the request
//  @return string
func (a *MessageAPIService) GetV1AccountAccountAttachmentAttachmentExecute(r ApiGetV1AccountAccountAttachmentAttachmentRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.GetV1AccountAccountAttachmentAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{account}/attachment/{attachment}"
	localVarPath = strings.Replace(localVarPath, "{"+"account"+"}", url.PathEscape(parameterValueToString(r.account, "account")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment"+"}", url.PathEscape(parameterValueToString(r.attachment, "attachment")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.account) > 256 {
		return localVarReturnValue, nil, reportError("account must have less than 256 elements")
	}
	if strlen(r.attachment) > 2048 {
		return localVarReturnValue, nil, reportError("attachment must have less than 2048 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEeTimeout != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ee-timeout", r.xEeTimeout, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetV1AccountAccountMessageMessageRequest struct {
	ctx context.Context
	ApiService *MessageAPIService
	account string
	message string
	xEeTimeout *int32
	maxBytes *int32
	textType *string
	webSafeHtml *bool
	embedAttachedImages *bool
	preProcessHtml *bool
	markAsSeen *bool
}

// Request timeout in milliseconds (overrides EENGINE_TIMEOUT environment variable)
func (r ApiGetV1AccountAccountMessageMessageRequest) XEeTimeout(xEeTimeout int32) ApiGetV1AccountAccountMessageMessageRequest {
	r.xEeTimeout = &xEeTimeout
	return r
}

// Max length of text content
func (r ApiGetV1AccountAccountMessageMessageRequest) MaxBytes(maxBytes int32) ApiGetV1AccountAccountMessageMessageRequest {
	r.maxBytes = &maxBytes
	return r
}

// Which text content to return, use * for all. By default text content is not returned.
func (r ApiGetV1AccountAccountMessageMessageRequest) TextType(textType string) ApiGetV1AccountAccountMessageMessageRequest {
	r.textType = &textType
	return r
}

// Shorthand option to fetch and preprocess HTML and inline images. Overrides &#x60;textType&#x60;, &#x60;preProcessHtml&#x60;, and &#x60;embedAttachedImages&#x60; options.
func (r ApiGetV1AccountAccountMessageMessageRequest) WebSafeHtml(webSafeHtml bool) ApiGetV1AccountAccountMessageMessageRequest {
	r.webSafeHtml = &webSafeHtml
	return r
}

// If true, then fetches attached images and embeds these in the HTML as data URIs
func (r ApiGetV1AccountAccountMessageMessageRequest) EmbedAttachedImages(embedAttachedImages bool) ApiGetV1AccountAccountMessageMessageRequest {
	r.embedAttachedImages = &embedAttachedImages
	return r
}

// If true, then pre-processes HTML for compatibility
func (r ApiGetV1AccountAccountMessageMessageRequest) PreProcessHtml(preProcessHtml bool) ApiGetV1AccountAccountMessageMessageRequest {
	r.preProcessHtml = &preProcessHtml
	return r
}

// If true, then marks unseen email as seen while returning the message
func (r ApiGetV1AccountAccountMessageMessageRequest) MarkAsSeen(markAsSeen bool) ApiGetV1AccountAccountMessageMessageRequest {
	r.markAsSeen = &markAsSeen
	return r
}

func (r ApiGetV1AccountAccountMessageMessageRequest) Execute() (*MessageDetails, *http.Response, error) {
	return r.ApiService.GetV1AccountAccountMessageMessageExecute(r)
}

/*
GetV1AccountAccountMessageMessage Get message information

Returns details of a specific message. By default text content is not included, use textType value to force retrieving text

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param account Unique identifier for the email account
 @param message Message ID
 @return ApiGetV1AccountAccountMessageMessageRequest
*/
func (a *MessageAPIService) GetV1AccountAccountMessageMessage(ctx context.Context, account string, message string) ApiGetV1AccountAccountMessageMessageRequest {
	return ApiGetV1AccountAccountMessageMessageRequest{
		ApiService: a,
		ctx: ctx,
		account: account,
		message: message,
	}
}

// Execute executes the request
//  @return MessageDetails
func (a *MessageAPIService) GetV1AccountAccountMessageMessageExecute(r ApiGetV1AccountAccountMessageMessageRequest) (*MessageDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.GetV1AccountAccountMessageMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{account}/message/{message}"
	localVarPath = strings.Replace(localVarPath, "{"+"account"+"}", url.PathEscape(parameterValueToString(r.account, "account")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message"+"}", url.PathEscape(parameterValueToString(r.message, "message")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.account) > 256 {
		return localVarReturnValue, nil, reportError("account must have less than 256 elements")
	}
	if strlen(r.message) > 256 {
		return localVarReturnValue, nil, reportError("message must have less than 256 elements")
	}

	if r.maxBytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxBytes", r.maxBytes, "form", "")
	}
	if r.textType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "textType", r.textType, "form", "")
	}
	if r.webSafeHtml != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webSafeHtml", r.webSafeHtml, "form", "")
	} else {
		var defaultValue bool = false
		r.webSafeHtml = &defaultValue
	}
	if r.embedAttachedImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embedAttachedImages", r.embedAttachedImages, "form", "")
	} else {
		var defaultValue bool = false
		r.embedAttachedImages = &defaultValue
	}
	if r.preProcessHtml != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preProcessHtml", r.preProcessHtml, "form", "")
	} else {
		var defaultValue bool = false
		r.preProcessHtml = &defaultValue
	}
	if r.markAsSeen != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsSeen", r.markAsSeen, "form", "")
	} else {
		var defaultValue bool = false
		r.markAsSeen = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEeTimeout != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ee-timeout", r.xEeTimeout, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetV1AccountAccountMessageMessageSourceRequest struct {
	ctx context.Context
	ApiService *MessageAPIService
	account string
	message string
	xEeTimeout *int32
}

// Request timeout in milliseconds (overrides EENGINE_TIMEOUT environment variable)
func (r ApiGetV1AccountAccountMessageMessageSourceRequest) XEeTimeout(xEeTimeout int32) ApiGetV1AccountAccountMessageMessageSourceRequest {
	r.xEeTimeout = &xEeTimeout
	return r
}

func (r ApiGetV1AccountAccountMessageMessageSourceRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetV1AccountAccountMessageMessageSourceExecute(r)
}

/*
GetV1AccountAccountMessageMessageSource Download raw message

Fetches raw message as a stream

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param account Unique identifier for the email account
 @param message Message ID
 @return ApiGetV1AccountAccountMessageMessageSourceRequest
*/
func (a *MessageAPIService) GetV1AccountAccountMessageMessageSource(ctx context.Context, account string, message string) ApiGetV1AccountAccountMessageMessageSourceRequest {
	return ApiGetV1AccountAccountMessageMessageSourceRequest{
		ApiService: a,
		ctx: ctx,
		account: account,
		message: message,
	}
}

// Execute executes the request
//  @return string
func (a *MessageAPIService) GetV1AccountAccountMessageMessageSourceExecute(r ApiGetV1AccountAccountMessageMessageSourceRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.GetV1AccountAccountMessageMessageSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{account}/message/{message}/source"
	localVarPath = strings.Replace(localVarPath, "{"+"account"+"}", url.PathEscape(parameterValueToString(r.account, "account")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message"+"}", url.PathEscape(parameterValueToString(r.message, "message")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.account) > 256 {
		return localVarReturnValue, nil, reportError("account must have less than 256 elements")
	}
	if strlen(r.message) > 256 {
		return localVarReturnValue, nil, reportError("message must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"message/rfc822"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEeTimeout != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ee-timeout", r.xEeTimeout, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetV1AccountAccountMessagesRequest struct {
	ctx context.Context
	ApiService *MessageAPIService
	account string
	path *string
	xEeTimeout *int32
	cursor *string
	page *int32
	pageSize *int32
}

// Mailbox folder path. Can use special use labels like \&quot;\\Sent\&quot;. Special value \&quot;\\All\&quot; is available for Gmail IMAP, Gmail API, MS Graph API accounts.
func (r ApiGetV1AccountAccountMessagesRequest) Path(path string) ApiGetV1AccountAccountMessagesRequest {
	r.path = &path
	return r
}

// Request timeout in milliseconds (overrides EENGINE_TIMEOUT environment variable)
func (r ApiGetV1AccountAccountMessagesRequest) XEeTimeout(xEeTimeout int32) ApiGetV1AccountAccountMessagesRequest {
	r.xEeTimeout = &xEeTimeout
	return r
}

// Paging cursor from &#x60;nextPageCursor&#x60; or &#x60;prevPageCursor&#x60; value
func (r ApiGetV1AccountAccountMessagesRequest) Cursor(cursor string) ApiGetV1AccountAccountMessagesRequest {
	r.cursor = &cursor
	return r
}

// Page number (zero-indexed, so use 0 for the first page). Only supported for IMAP accounts. Deprecated; use the paging cursor instead. If the page cursor value is provided, then the page number value is ignored.
func (r ApiGetV1AccountAccountMessagesRequest) Page(page int32) ApiGetV1AccountAccountMessagesRequest {
	r.page = &page
	return r
}

// How many entries per page
func (r ApiGetV1AccountAccountMessagesRequest) PageSize(pageSize int32) ApiGetV1AccountAccountMessagesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetV1AccountAccountMessagesRequest) Execute() (*MessageList, *http.Response, error) {
	return r.ApiService.GetV1AccountAccountMessagesExecute(r)
}

/*
GetV1AccountAccountMessages List messages in a folder

Lists messages in a mailbox folder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param account Unique identifier for the email account
 @return ApiGetV1AccountAccountMessagesRequest
*/
func (a *MessageAPIService) GetV1AccountAccountMessages(ctx context.Context, account string) ApiGetV1AccountAccountMessagesRequest {
	return ApiGetV1AccountAccountMessagesRequest{
		ApiService: a,
		ctx: ctx,
		account: account,
	}
}

// Execute executes the request
//  @return MessageList
func (a *MessageAPIService) GetV1AccountAccountMessagesExecute(r ApiGetV1AccountAccountMessagesRequest) (*MessageList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.GetV1AccountAccountMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{account}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"account"+"}", url.PathEscape(parameterValueToString(r.account, "account")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.account) > 256 {
		return localVarReturnValue, nil, reportError("account must have less than 256 elements")
	}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEeTimeout != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ee-timeout", r.xEeTimeout, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetV1AccountAccountTextTextRequest struct {
	ctx context.Context
	ApiService *MessageAPIService
	account string
	text string
	xEeTimeout *int32
	maxBytes *int32
	textType *string
}

// Request timeout in milliseconds (overrides EENGINE_TIMEOUT environment variable)
func (r ApiGetV1AccountAccountTextTextRequest) XEeTimeout(xEeTimeout int32) ApiGetV1AccountAccountTextTextRequest {
	r.xEeTimeout = &xEeTimeout
	return r
}

// Max length of text content
func (r ApiGetV1AccountAccountTextTextRequest) MaxBytes(maxBytes int32) ApiGetV1AccountAccountTextTextRequest {
	r.maxBytes = &maxBytes
	return r
}

// Which text content to return, use * for all. By default all contents are returned.
func (r ApiGetV1AccountAccountTextTextRequest) TextType(textType string) ApiGetV1AccountAccountTextTextRequest {
	r.textType = &textType
	return r
}

func (r ApiGetV1AccountAccountTextTextRequest) Execute() (*TextResponse, *http.Response, error) {
	return r.ApiService.GetV1AccountAccountTextTextExecute(r)
}

/*
GetV1AccountAccountTextText Retrieve message text

Retrieves message text

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param account Unique identifier for the email account
 @param text Message text ID
 @return ApiGetV1AccountAccountTextTextRequest
*/
func (a *MessageAPIService) GetV1AccountAccountTextText(ctx context.Context, account string, text string) ApiGetV1AccountAccountTextTextRequest {
	return ApiGetV1AccountAccountTextTextRequest{
		ApiService: a,
		ctx: ctx,
		account: account,
		text: text,
	}
}

// Execute executes the request
//  @return TextResponse
func (a *MessageAPIService) GetV1AccountAccountTextTextExecute(r ApiGetV1AccountAccountTextTextRequest) (*TextResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TextResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.GetV1AccountAccountTextText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{account}/text/{text}"
	localVarPath = strings.Replace(localVarPath, "{"+"account"+"}", url.PathEscape(parameterValueToString(r.account, "account")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"text"+"}", url.PathEscape(parameterValueToString(r.text, "text")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.account) > 256 {
		return localVarReturnValue, nil, reportError("account must have less than 256 elements")
	}
	if strlen(r.text) > 10240 {
		return localVarReturnValue, nil, reportError("text must have less than 10240 elements")
	}

	if r.maxBytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxBytes", r.maxBytes, "form", "")
	}
	if r.textType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "textType", r.textType, "form", "")
	} else {
		var defaultValue string = "*"
		r.textType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEeTimeout != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ee-timeout", r.xEeTimeout, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostV1AccountAccountMessageRequest struct {
	ctx context.Context
	ApiService *MessageAPIService
	account string
	xEeTimeout *int32
	messageUpload *MessageUpload
}

// Request timeout in milliseconds (overrides EENGINE_TIMEOUT environment variable)
func (r ApiPostV1AccountAccountMessageRequest) XEeTimeout(xEeTimeout int32) ApiPostV1AccountAccountMessageRequest {
	r.xEeTimeout = &xEeTimeout
	return r
}

func (r ApiPostV1AccountAccountMessageRequest) MessageUpload(messageUpload MessageUpload) ApiPostV1AccountAccountMessageRequest {
	r.messageUpload = &messageUpload
	return r
}

func (r ApiPostV1AccountAccountMessageRequest) Execute() (*MessageUploadResponse, *http.Response, error) {
	return r.ApiService.PostV1AccountAccountMessageExecute(r)
}

/*
PostV1AccountAccountMessage Upload message

Upload a message structure, compile it into an EML file and store it into selected mailbox.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param account Unique identifier for the email account
 @return ApiPostV1AccountAccountMessageRequest
*/
func (a *MessageAPIService) PostV1AccountAccountMessage(ctx context.Context, account string) ApiPostV1AccountAccountMessageRequest {
	return ApiPostV1AccountAccountMessageRequest{
		ApiService: a,
		ctx: ctx,
		account: account,
	}
}

// Execute executes the request
//  @return MessageUploadResponse
func (a *MessageAPIService) PostV1AccountAccountMessageExecute(r ApiPostV1AccountAccountMessageRequest) (*MessageUploadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageUploadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.PostV1AccountAccountMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{account}/message"
	localVarPath = strings.Replace(localVarPath, "{"+"account"+"}", url.PathEscape(parameterValueToString(r.account, "account")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.account) > 256 {
		return localVarReturnValue, nil, reportError("account must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEeTimeout != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ee-timeout", r.xEeTimeout, "simple", "")
	}
	// body params
	localVarPostBody = r.messageUpload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostV1AccountAccountSearchRequest struct {
	ctx context.Context
	ApiService *MessageAPIService
	account string
	xEeTimeout *int32
	path *string
	cursor *string
	page *int32
	pageSize *int32
	useOutlookSearch *bool
	model9 *Model9
}

// Request timeout in milliseconds (overrides EENGINE_TIMEOUT environment variable)
func (r ApiPostV1AccountAccountSearchRequest) XEeTimeout(xEeTimeout int32) ApiPostV1AccountAccountSearchRequest {
	r.xEeTimeout = &xEeTimeout
	return r
}

// Mailbox folder path. Can use special use labels like \&quot;\\Sent\&quot;. Special value \&quot;\\All\&quot; is available for Gmail IMAP, Gmail API, MS Graph API accounts.
func (r ApiPostV1AccountAccountSearchRequest) Path(path string) ApiPostV1AccountAccountSearchRequest {
	r.path = &path
	return r
}

// Paging cursor from &#x60;nextPageCursor&#x60; or &#x60;prevPageCursor&#x60; value
func (r ApiPostV1AccountAccountSearchRequest) Cursor(cursor string) ApiPostV1AccountAccountSearchRequest {
	r.cursor = &cursor
	return r
}

// Page number (zero-indexed, so use 0 for the first page). Only supported for IMAP accounts. Deprecated; use the paging cursor instead. If the page cursor value is provided, then the page number value is ignored.
func (r ApiPostV1AccountAccountSearchRequest) Page(page int32) ApiPostV1AccountAccountSearchRequest {
	r.page = &page
	return r
}

// How many entries per page
func (r ApiPostV1AccountAccountSearchRequest) PageSize(pageSize int32) ApiPostV1AccountAccountSearchRequest {
	r.pageSize = &pageSize
	return r
}

// MS Graph only. If enabled, uses the $search parameter for MS Graph search queries instead of $filter. This allows searching the \&quot;to\&quot;, \&quot;cc\&quot;, \&quot;bcc\&quot;, \&quot;larger\&quot;, \&quot;smaller\&quot;, \&quot;body\&quot;, \&quot;before\&quot;, \&quot;sentBefore\&quot;, \&quot;since\&quot;, and the \&quot;sentSince\&quot; fields. Note that $search returns up to 1,000 results, does not indicate the total number of matching results or pages, and returns results sorted by relevance rather than date.
func (r ApiPostV1AccountAccountSearchRequest) UseOutlookSearch(useOutlookSearch bool) ApiPostV1AccountAccountSearchRequest {
	r.useOutlookSearch = &useOutlookSearch
	return r
}

func (r ApiPostV1AccountAccountSearchRequest) Model9(model9 Model9) ApiPostV1AccountAccountSearchRequest {
	r.model9 = &model9
	return r
}

func (r ApiPostV1AccountAccountSearchRequest) Execute() (*MessageList, *http.Response, error) {
	return r.ApiService.PostV1AccountAccountSearchExecute(r)
}

/*
PostV1AccountAccountSearch Search for messages

Filter messages from a mailbox folder by search options. Search is performed against a specific folder and not for the entire account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param account Unique identifier for the email account
 @return ApiPostV1AccountAccountSearchRequest
*/
func (a *MessageAPIService) PostV1AccountAccountSearch(ctx context.Context, account string) ApiPostV1AccountAccountSearchRequest {
	return ApiPostV1AccountAccountSearchRequest{
		ApiService: a,
		ctx: ctx,
		account: account,
	}
}

// Execute executes the request
//  @return MessageList
func (a *MessageAPIService) PostV1AccountAccountSearchExecute(r ApiPostV1AccountAccountSearchRequest) (*MessageList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.PostV1AccountAccountSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{account}/search"
	localVarPath = strings.Replace(localVarPath, "{"+"account"+"}", url.PathEscape(parameterValueToString(r.account, "account")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.account) > 256 {
		return localVarReturnValue, nil, reportError("account must have less than 256 elements")
	}

	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.useOutlookSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useOutlookSearch", r.useOutlookSearch, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEeTimeout != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ee-timeout", r.xEeTimeout, "simple", "")
	}
	// body params
	localVarPostBody = r.model9
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutV1AccountAccountMessageMessageRequest struct {
	ctx context.Context
	ApiService *MessageAPIService
	account string
	message string
	xEeTimeout *int32
	messageUpdate *MessageUpdate
}

// Request timeout in milliseconds (overrides EENGINE_TIMEOUT environment variable)
func (r ApiPutV1AccountAccountMessageMessageRequest) XEeTimeout(xEeTimeout int32) ApiPutV1AccountAccountMessageMessageRequest {
	r.xEeTimeout = &xEeTimeout
	return r
}

func (r ApiPutV1AccountAccountMessageMessageRequest) MessageUpdate(messageUpdate MessageUpdate) ApiPutV1AccountAccountMessageMessageRequest {
	r.messageUpdate = &messageUpdate
	return r
}

func (r ApiPutV1AccountAccountMessageMessageRequest) Execute() (*Model29, *http.Response, error) {
	return r.ApiService.PutV1AccountAccountMessageMessageExecute(r)
}

/*
PutV1AccountAccountMessageMessage Update message

Update message information. Mainly this means changing message flag values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param account Unique identifier for the email account
 @param message Message ID
 @return ApiPutV1AccountAccountMessageMessageRequest
*/
func (a *MessageAPIService) PutV1AccountAccountMessageMessage(ctx context.Context, account string, message string) ApiPutV1AccountAccountMessageMessageRequest {
	return ApiPutV1AccountAccountMessageMessageRequest{
		ApiService: a,
		ctx: ctx,
		account: account,
		message: message,
	}
}

// Execute executes the request
//  @return Model29
func (a *MessageAPIService) PutV1AccountAccountMessageMessageExecute(r ApiPutV1AccountAccountMessageMessageRequest) (*Model29, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Model29
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.PutV1AccountAccountMessageMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{account}/message/{message}"
	localVarPath = strings.Replace(localVarPath, "{"+"account"+"}", url.PathEscape(parameterValueToString(r.account, "account")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message"+"}", url.PathEscape(parameterValueToString(r.message, "message")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.account) > 256 {
		return localVarReturnValue, nil, reportError("account must have less than 256 elements")
	}
	if strlen(r.message) > 256 {
		return localVarReturnValue, nil, reportError("message must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEeTimeout != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ee-timeout", r.xEeTimeout, "simple", "")
	}
	// body params
	localVarPostBody = r.messageUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutV1AccountAccountMessageMessageMoveRequest struct {
	ctx context.Context
	ApiService *MessageAPIService
	account string
	message string
	xEeTimeout *int32
	messageMove *MessageMove
}

// Request timeout in milliseconds (overrides EENGINE_TIMEOUT environment variable)
func (r ApiPutV1AccountAccountMessageMessageMoveRequest) XEeTimeout(xEeTimeout int32) ApiPutV1AccountAccountMessageMessageMoveRequest {
	r.xEeTimeout = &xEeTimeout
	return r
}

func (r ApiPutV1AccountAccountMessageMessageMoveRequest) MessageMove(messageMove MessageMove) ApiPutV1AccountAccountMessageMessageMoveRequest {
	r.messageMove = &messageMove
	return r
}

func (r ApiPutV1AccountAccountMessageMessageMoveRequest) Execute() (*MessageMoveResponse, *http.Response, error) {
	return r.ApiService.PutV1AccountAccountMessageMessageMoveExecute(r)
}

/*
PutV1AccountAccountMessageMessageMove Move a message to a specified folder

Moves a message to a target folder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param account Unique identifier for the email account
 @param message Message ID
 @return ApiPutV1AccountAccountMessageMessageMoveRequest
*/
func (a *MessageAPIService) PutV1AccountAccountMessageMessageMove(ctx context.Context, account string, message string) ApiPutV1AccountAccountMessageMessageMoveRequest {
	return ApiPutV1AccountAccountMessageMessageMoveRequest{
		ApiService: a,
		ctx: ctx,
		account: account,
		message: message,
	}
}

// Execute executes the request
//  @return MessageMoveResponse
func (a *MessageAPIService) PutV1AccountAccountMessageMessageMoveExecute(r ApiPutV1AccountAccountMessageMessageMoveRequest) (*MessageMoveResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageMoveResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessageAPIService.PutV1AccountAccountMessageMessageMove")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{account}/message/{message}/move"
	localVarPath = strings.Replace(localVarPath, "{"+"account"+"}", url.PathEscape(parameterValueToString(r.account, "account")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message"+"}", url.PathEscape(parameterValueToString(r.message, "message")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.account) > 256 {
		return localVarReturnValue, nil, reportError("account must have less than 256 elements")
	}
	if strlen(r.message) > 256 {
		return localVarReturnValue, nil, reportError("message must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xEeTimeout != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ee-timeout", r.xEeTimeout, "simple", "")
	}
	// body params
	localVarPostBody = r.messageMove
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
